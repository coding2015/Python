#!/bin/usr/python

chapter 15:
		network programming


socket module:
---------------------------------------------------
common functions:

服务端
accep(self) -> (socket-obj, addr-info)
bind(addr)	#addr: (host, port)
listen(backlog)

客户端
connect(addr)
connect_ex(addr)	#同connect()， 但出错时不报异常而是返回错误码

公用
socket(family=AF_INET, type=SOCK_STREAM, protocol=0) -> socket object
send(str[, flags])
sendto(data[, flags], addr)
recv(buflen[, flags]) -> data(str)
recvfrom(buflen[, flags]) -> (data, addr(sender))

----------------------------------------------------
TCP-服务器通用伪代码：

ss = socket()	# 创建服务器套接字
ss.bind()		# 把地址绑定到套接字上
ss.listen()		# 监听连接
inf_loop:		# 服务器无限循环
	cs = ss.accept()	# 接受客户的连接
	comm_loop:			# 通讯循环
		cs.recv/cs.send()	# 对话(接收与发送到客户端)
	cs.close()			# 关闭客户端套接字
ss.close()		# 关闭服务器套接字

-----------------------------------------------------
TCP-客户端通用伪代码：

cs = sockets()	# 创建客户端套接字
cd.connect()	# 尝试连接服务器
comm_loop:		# 通讯循环
	cd.send()/cs.recv()	# 对话(发送/接收)
cs.close()		# 关闭客户端套接字

-----------------------------------------------------
UDP-服务器通用伪代码

ss = socket()	# 创建服务器套接字
ss.bind()		# 绑定服务器套接字
inf_loop:		# 服务器无限循环
	cs = ss.recvfrom()/ss.sendto()	# 对话(接收与发送)
ss.close()		# 关闭服务器套接字

-----------------------------------------------------
UDP-客户端通用伪代码

cs = socket()	# 创建客户端套接字
comm_loop:		# 通讯循环
	cs.sendto()/cs.recvfrom()	# 对话（发送/接收）
cs.close		# 关闭客户端套接字
