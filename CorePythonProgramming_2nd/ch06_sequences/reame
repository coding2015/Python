#!/usr/bin/python

chapter 6:
	Sequences: Strings, Lists, Tuples

-------------------------------------------------------
'序列'
     	str, list, tuple
		元素顺序存储，按数值顺序序列化排序

--------------------------------------------------------		
'序列操作'

'成员关系操作符 in, not in'
		判断某一对象是否在序列中
			>>> 'er' in 'werw'
			True
			>>> [1,2] in [1,2,3]
			False
			>>> 2 in [1,2,3]
			True

'切片操作符 []或[:]或[::]'
		序列索引范围: [0, len(seq)-1] 

	 	seq[index] -> 返回索引值为index的元素， 索引值超出范围时报错:IndexError
		seq[beg:end] -> 返回子集，子集为索引值范围在beg-end(不包括end)的所有元素
						若beg:end包含序列范围，返回序列本身
						若beg:end不包含序列范围，返回空子集:()或[] 
						[beg:] -> [beg:len(seq)], 返回从beg开始的所有元素
						[:end] -> [0, end], 返回从0开始到end(不包括end)的所有元素
		seq[beg:end:step] -> 返回子集，从beg开始到end(不包括end),取以step为间隔的元素
				>>> l = [1,2,3,4,5,6,7]
				>>> l[::-2]
				[7, 5, 3, 1]
				>>> l[::]
				[1, 2, 3, 4, 5, 6, 7]

		
'重复操作符*'
		seq * num -> new-seq of copy num times of each element of old-seq  
		该过程为浅拷贝, 所有的副本都为原元素的引用
		若元素为可变对象时， 改动其中一个副本，则所有副本都会改变
			>>> (2,) * 5
			(2, 2, 2, 2, 2)
			>>> [] * 5
			[]
			>>> list = [[]] * 5		# 元素为可变对象时
			>>> filter(lambda e:e is list[0], list)
			[[], [], [], [], []]
			>>> list[0].append(10)	# 改变其中一个副本
			>>> list
			[[10], [10], [10], [10], [10]]	# 所有副本都跟着改变
			>>> filter(lambda e:e is list[0], list)
			[[10], [10], [10], [10], [10]]

'连接操作符'
		seq1 + seq2 -> seq of seq1 and seq2
		注: seq1 和 seq2 需是同类型序列
			>>> (1,2)+(2,4)
			(1, 2, 2, 4)
		出于性能考虑，
			对于字符串的连接建议用 str.join(seq)
			对于列表的连接建议用 list.expend(iterable)

---------------------------------------------------------
'细节点'
		定义只含一个元素的元组时， 元素后需加逗号','来表示这是一个元组
								否则会被识别为一个对象类型
		>>> ([2])
		[2]		# 被识别为列表本身
		>>> ([2],)
		([2],)	# 带一个列表元素的序列

